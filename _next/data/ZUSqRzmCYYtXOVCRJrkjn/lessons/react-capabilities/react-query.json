{"pageProps":{"post":{"attributes":{"description":"","title":"react-query"},"html":"<p>As we saw in the <a href=\"/core-react-concepts/effects\">Effects lesson</a> React has the ability to render, make a request to an async data source (like an API), and then re-render after the new data comes in. <code>useEffect</code> accomplishes this goal precisely.</p>\n<p>However, take it from me, when you start having a <em>lot</em> of effects in an app, it quickly can get unruly of what effect is happening when and performance can also begin to suffer when effects start happening in a rapid succession. It&#39;s possible to manage, just can be hard to wrap your mind around.</p>\n<p>Here I am going to teach you a library called <a href=\"https://tanstack.com/query/v4\">@tanstack/react-query</a>.</p>\n<pre><code class=\"hljs language-bash\">npm install @tanstack/react-query@4.10.1\n</code></pre>\n<blockquote>\n<p><code>@tanstack/react-query</code> is the same people who do <code>react-query</code>. This is just the newer version. They now support than just React.</p>\n</blockquote>\n<p>The idea behind React is that you want to cache most of what you fetch from a database. If you fetch the details of pet ID 1, you generally do no want to fetch it again if a user revisits that page: you&#39;d like to cache it. This is what react-query is going to do for you: it&#39;s a built in caching layer for these async data stores that works really well within the constraints of React. Let&#39;s see how to make make our Details page use it.</p>\n<p>First thing, we need to wrap our app in a query client. In theory we could have multiple query clients for our app if we wanted multiple different caches to draw from (though I struggle to conceive of a reason to do that.) More concretely though is that it using React context to pass our app&#39;s cache around. So let&#39;s go handle that.</p>\n<p>In App.jsx</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// at top</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">QueryClient</span>, <span class=\"hljs-title class_\">QueryClientProvider</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@tanstack/react-query&quot;</span>;\n<span class=\"hljs-keyword\">const</span> queryClient = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">QueryClient</span>({\n  <span class=\"hljs-attr\">defaultOptions</span>: {\n    <span class=\"hljs-attr\">queries</span>: {\n      <span class=\"hljs-attr\">staleTime</span>: <span class=\"hljs-title class_\">Infinity</span>,\n      <span class=\"hljs-attr\">cacheTime</span>: <span class=\"hljs-title class_\">Infinity</span>,\n    },\n  },\n});\n\n<span class=\"hljs-comment\">// inside &lt;BrowserRouter&gt; wrapping everything inside it</span>\n<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">QueryClientProvider</span> <span class=\"hljs-attr\">client</span>=<span class=\"hljs-string\">{queryClient}</span>&gt;</span>\n […]\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">QueryClientProvider</span>&gt;</span></span>\n</code></pre>\n<p>This will wrap our app with the provider necessary to power react-query. We have to give it cache and stale times so that it will actually use its caching layer. Otherwise it&#39;ll fetch each time. Here we&#39;re saying &quot;never invalidate&quot; but in many apps you&#39;d probably want to still fetch every few minutes or so.</p>\n<p>Now make a file called fetchPet.js (or jsx):</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">fetchPet</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">{ queryKey }</span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> id = queryKey[<span class=\"hljs-number\">1</span>];\n  <span class=\"hljs-keyword\">const</span> apiRes = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">`http://pets-v2.dev-apis.com/pets?id=<span class=\"hljs-subst\">${id}</span>`</span>);\n\n  <span class=\"hljs-keyword\">if</span> (!apiRes.<span class=\"hljs-property\">ok</span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">`details/<span class=\"hljs-subst\">${id}</span> fetch not ok`</span>);\n  }\n\n  <span class=\"hljs-keyword\">return</span> apiRes.<span class=\"hljs-title function_\">json</span>();\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> fetchPet;\n</code></pre>\n<p>This is the function that will actually make the request to the API.</p>\n<ul>\n<li>Splitting it out allows it to be independently testable and reusable across our app</li>\n<li>Notice the <code>if</code> conditional. We need it to throw if there&#39;s an error and fetch wouldn&#39;t throw here if there&#39;s a 400 or a 500 error. We need it to.</li>\n<li>Notice we don&#39;t await the <code>json</code> response. Any async function is going to return a promise anyway so we don&#39;t need to await it in the function body. You could. It would do the same thing.</li>\n</ul>\n<p>Okay, let&#39;s change Details.jsx now</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> { useParams } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { useQuery } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@tanstack/react-query&quot;</span>;\n<span class=\"hljs-keyword\">import</span> fetchPet <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./fetchPet&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Details</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> { id } = <span class=\"hljs-title function_\">useParams</span>();\n  <span class=\"hljs-keyword\">const</span> results = <span class=\"hljs-title function_\">useQuery</span>([<span class=\"hljs-string\">&quot;details&quot;</span>, id], fetchPet);\n\n  <span class=\"hljs-keyword\">if</span> (results.<span class=\"hljs-property\">isLoading</span>) {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;loading-pane&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;loader&quot;</span>&gt;</span>🌀<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n    );\n  }\n\n  <span class=\"hljs-keyword\">const</span> pet = results.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">pets</span>[<span class=\"hljs-number\">0</span>];\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;details&quot;</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>{pet.name}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>{`${pet.animal} — ${pet.breed} — ${pet.city}, ${pet.state}`}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>&gt;</span>Adopt {pet.name}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>{pet.description}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Details</span>;\n</code></pre>\n<ul>\n<li>useQuery will actually use the queryClient that we instantiated above via context (we have a whole section later on context.)</li>\n<li>The first thing you give to useQuery is the query key. It could be a string e.g. we could have done <code>details:1</code> as the key for details 1 (similar to a Redis strategy for key naming.) However I like the array methodology. You can give it an array of keys. So the first key is <code>details</code> and then a subkey of that is <code>1</code> and it has to match both. You can also do it with objects and we will momentarily.</li>\n<li>The results object has a lot of booleans on it for isLoading, isError, isFetching, isPaused, etc. In this case react-query will make it <em>start</em> its first fetch (but not finish) and then continue rendering. Therefore we <em>must</em> handle the <code>isLoading</code> case (in addition to that just being a good idea)</li>\n</ul>\n<p>This should all work now! Notice if we navigate back and forth from a page, the first time it will load it and the second time it won&#39;t; it&#39;ll just pull it from the cache! Perfect! Exactly what we wanted.</p>\n<p>Let&#39;s go do useBreedList.js. First, let&#39;s split out the fetch command into fetchBreedList.js</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fetchBreedList</span>(<span class=\"hljs-params\">{ queryKey }</span>) {\n  <span class=\"hljs-keyword\">const</span> animal = queryKey[<span class=\"hljs-number\">1</span>];\n\n  <span class=\"hljs-keyword\">if</span> (!animal) <span class=\"hljs-keyword\">return</span> [];\n\n  <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(\n    <span class=\"hljs-string\">`http://pets-v2.dev-apis.com/breeds?animal=<span class=\"hljs-subst\">${animal}</span>`</span>\n  );\n\n  <span class=\"hljs-keyword\">if</span> (!res.<span class=\"hljs-property\">ok</span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">`breeds <span class=\"hljs-subst\">${animal}</span> fetch not ok`</span>);\n  }\n\n  <span class=\"hljs-keyword\">return</span> res.<span class=\"hljs-title function_\">json</span>();\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> fetchBreedList;\n</code></pre>\n<p>And now refactor useBreedList.js</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> { useQuery } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@tanstack/react-query&quot;</span>;\n<span class=\"hljs-keyword\">import</span> fetchBreedList <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./fetchBreedList&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">useBreedList</span>(<span class=\"hljs-params\">animal</span>) {\n  <span class=\"hljs-keyword\">const</span> results = <span class=\"hljs-title function_\">useQuery</span>([<span class=\"hljs-string\">&quot;breeds&quot;</span>, animal], fetchBreedList);\n\n  <span class=\"hljs-keyword\">return</span> [results?.<span class=\"hljs-property\">data</span>?.<span class=\"hljs-property\">breeds</span> ?? [], results.<span class=\"hljs-property\">status</span>];\n}\n</code></pre>\n<p>This got <em>a lot</em> simpler, didn&#39;t it? It&#39;s because react-query handles all the caching for us instead of us having to. Now go click around the animals drop down and see if it still works okay.</p>\n<h2 id=\"mutations\">Mutations</h2>\n<p>In this class we&#39;re just looking at fetching data from the server. These can be cached and we can avoid calling the server again if we have same parameters. However a mutation always needs to run: if we are trying to change something on the server, we can&#39;t avoid that call. That&#39;s where a mutation comes into play.</p>\n<p><a href=\"https://tanstack.com/query/v4/docs/guides/mutations\">See the documentation here</a>.</p>\n<p>Nearly all the same concepts at play, just a little different to handle the fact you&#39;re POSTing data to a server.</p>\n<blockquote>\n<p>🏁 <a href=\"https://github.com/btholt/citr-v8-project/tree/master/09-react-query\">Click here to see the state of the project up until now: 09-react-query</a></p>\n</blockquote>\n","slug":"react-query","title":"react-query","section":"React Capabilities","icon":"map","filePath":"/home/runner/work/complete-intro-to-react-v8/complete-intro-to-react-v8/lessons/05-react-capabilities/B-react-query.md","nextSlug":"/lessons/react-capabilities/uncontrolled-forms","prevSlug":"/lessons/react-capabilities/react-router"}},"__N_SSG":true}