{"pageProps":{"post":{"attributes":{"description":"useEffect is a criticl hook for React, allowing developers to do asynchronous actions like making HTTP requests"},"html":"<p>We have enough to start making some requests now. We want the app to request an initial set of pets on initial load of the page. So let&#39;s make that happen using a special hook called <code>useEffect</code>. <code>useEffect</code> allows you to say &quot;do a render of this component first so the user can see <em>something</em> then as soon as the render is done, <em>then</em> do something (the something here being an effect.) In our case, we want the user to see our UI first then we want to make a request to the API so we can that initial list of pets.</p>\n<p>Add this to SearchParams.jsx:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// change import at top</span>\n<span class=\"hljs-keyword\">import</span> { useEffect, useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Pet</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./Pet&quot;</span>;\n\n<span class=\"hljs-comment\">// add to the other useStates inside component at top</span>\n<span class=\"hljs-keyword\">const</span> [pets, setPets] = <span class=\"hljs-title function_\">useState</span>([]);\n\n<span class=\"hljs-comment\">// add inside component, beneath all the `useState` setup</span>\n<span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-title function_\">requestPets</span>();\n}, []); <span class=\"hljs-comment\">// eslint-disable-line react-hooks/exhaustive-deps</span>\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">requestPets</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(\n    <span class=\"hljs-string\">`http://pets-v2.dev-apis.com/pets?animal=<span class=\"hljs-subst\">${animal}</span>&amp;location=<span class=\"hljs-subst\">${location}</span>&amp;breed=<span class=\"hljs-subst\">${breed}</span>`</span>\n  );\n  <span class=\"hljs-keyword\">const</span> json = <span class=\"hljs-keyword\">await</span> res.<span class=\"hljs-title function_\">json</span>();\n\n  <span class=\"hljs-title function_\">setPets</span>(json.<span class=\"hljs-property\">pets</span>);\n}\n\n<span class=\"hljs-comment\">// in jsx, under form, inside the larger div</span>\n{\n  pets.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">pet</span>) =&gt;</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Pet</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">{pet.name}</span> <span class=\"hljs-attr\">animal</span>=<span class=\"hljs-string\">{pet.animal}</span> <span class=\"hljs-attr\">breed</span>=<span class=\"hljs-string\">{pet.breed}</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{pet.id}</span> /&gt;</span></span>\n  ));\n}\n</code></pre>\n<ul>\n<li>We&#39;re taking advantage of closures here that if we define the requestPets function <em>inside</em> of the render that it will have access to that scope and can use all the hooks there.</li>\n<li>We could have actually put requestPets inside of the effect but we&#39;re going to use it again here in a sec with the submit button.</li>\n<li>the <code>[]</code> at the end of the useEffect is where you declare your data dependencies. React wants to know <em>when</em> to run that effect again. You don&#39;t give it data dependencies, it assumes any time any hook changes that you should run the effect again. This is bad because that would mean any time setPets gets called it&#39;d re-run render and all the hooks again. See a problem there? It&#39;d run infinitely since requestPets calls setPets.</li>\n<li>You can instead provide which hooks to watch for changes for. In our case, we actually only want it to run once, on creation of the component, and then to not run that effect again. (we&#39;ll do searching later via clicking the submit button) You can accomplish this only-run-on-creation by providing an empty array.</li>\n<li>The <code>// eslint-disable-line react-hooks/exhaustive-deps</code> tells eslint to shut up about this one run on this one line. Why? Because eslint tries to help you with you the data dependencies rule by watching for anything that <em>could</em> change. In this case, in theory the function could change but we know it&#39;s not important. You&#39;ll end up silencing this rule a fair bit.</li>\n<li>We could solve this by moving the requestPets function inside the effect and rely on React to call the fetch upon effect. This strategy would mean any time a user types in the location (and thus calls setState on the location) it&#39;d request from the API. This could work for you but for now we&#39;ll retain more control and just do it on submit events. It&#39;s all about managing when those effects go off. For now we just want this effect run once at the beginning and then not again.</li>\n<li>At the end, we gather take the pets we got back from the API and create Pet components out of each of them.</li>\n</ul>\n<blockquote>\n<p>üèÅ <a href=\"https://github.com/btholt/citr-v8-project/tree/master/05-useeffect\">Click here to see the state of the project up until now: 05-useeffect</a></p>\n</blockquote>\n","slug":"effects","title":"Effects","section":"Core React Concepts","icon":"book","filePath":"/home/runner/work/complete-intro-to-react-v8/complete-intro-to-react-v8/lessons/04-core-react-concepts/C-effects.md","nextSlug":"/lessons/core-react-concepts/custom-hooks","prevSlug":"/lessons/core-react-concepts/hooks"}},"__N_SSG":true}