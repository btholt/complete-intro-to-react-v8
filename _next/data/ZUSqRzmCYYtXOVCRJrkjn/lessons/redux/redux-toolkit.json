{"pageProps":{"post":{"attributes":{"description":""},"html":"<p>Redux is a well-known library that does state management for you, very similarly to how we used context. With context, you use the provider and consumer as a sort of portal to skip passing parameters through every component. With Redux, we&#39;re taking the state management <em>out</em> of React entirely and moving it to a separate store.</p>\n<p>Why do we have Redux?</p>\n<ol>\n<li>Context used to be a lot worse to use and less useful. This made Redux (or Redux-like) management tools the only option</li>\n<li>Redux code is <em>extremely testable</em>. This is probably the most compelling reason to use it. Having your state mutation be broken up in such a way to make it easy to test is fantastic. This is also mitigated because we have <code>useReducer</code> now.</li>\n<li>The debugging story is very good.</li>\n</ol>\n<p>So given that we do now have the next context API, how often will I use Redux? That answer was previously &quot;never&quot; but now it&#39;s probably &quot;sometimes&quot; because of how good a project called Redux Toolkit is (which I will call RTK from now on, as does everyone else.) RTK took the hard parts of Redux and made them much more simple.</p>\n<p>Okay, let&#39;s get started. React state management is pretty simple: call setState and let React re-render. That&#39;s it! With plain Redux without RTK it used to be:</p>\n<ol>\n<li>User types in input box</li>\n<li>Call action creator to get an action</li>\n<li>Dispatch action to Redux</li>\n<li>Redux inserts the action into the root reducer</li>\n<li>The root reducer delegates that action to the correct reducer</li>\n<li>The reducer returns a new state given the old state and the action object</li>\n<li>That new state becomes the store&#39;s state</li>\n<li>React is then called by Redux and told to update</li>\n</ol>\n<p>So what was one step became several. But each step of this is testable, and that&#39;s great. And it&#39;s explicit and verbose. It&#39;s long to follow, but it&#39;s an easy breadcrumb trailer to follow when things go awry.</p>\n<p>But now it&#39;s much easier. RTK cuts out a lot of that boiler plate and made it much easier to write and not have to write all that boilerplate.</p>\n<p>So let&#39;s get started. Run</p>\n<pre><code class=\"hljs language-bash\">npm install @reduxjs/toolkit@1.8.6 react-redux@8.0.4\n</code></pre>\n<p>Create store.js and put in it:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> { configureStore } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@reduxjs/toolkit&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> store = <span class=\"hljs-title function_\">configureStore</span>({\n  <span class=\"hljs-attr\">reducer</span>: {},\n});\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> store;\n</code></pre>\n<p>In App.jsx</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// delete AdoptedPetContext import</span>\n<span class=\"hljs-comment\">// delete useState import from React</span>\n\n<span class=\"hljs-comment\">// add import at top</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Provider</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-redux&quot;</span>;\n<span class=\"hljs-keyword\">import</span> store <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./store&quot;</span>;\n\n<span class=\"hljs-comment\">// delete useState call in function</span>\n<span class=\"hljs-comment\">// delete &lt;AdoptedPetContext.Provder&gt; component</span>\n\n<span class=\"hljs-comment\">// first component inside BrowserRouter</span>\n<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Provider</span> <span class=\"hljs-attr\">store</span>=<span class=\"hljs-string\">{store}</span>&gt;</span>[…]<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Provider</span>&gt;</span></span>;\n</code></pre>\n<p>This is the base store. The store is a centralized repo of data for your app. Think of it almost like a local database you can send queries and mutations too. It doesn&#39;t totally eclipse the need of local <code>useState</code> in React but it does in <em>some</em> of the cases. Typically it&#39;s going to be for app state sort of things. A general good rule of thumb is &quot;if this component unmounts, do I want to keep the state?&quot; If yes, might be app state and belongs in Redux. If no, probably not.</p>\n<p>So let&#39;s go make our existing context adopted pet in Redux instead of React context.</p>\n<ul>\n<li>Delete AdoptedPetContext.js</li>\n<li>Create adoptedPetSlice.js</li>\n</ul>\n<p>In there put:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> { createSlice } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@reduxjs/toolkit&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> adoptedPetSlice = <span class=\"hljs-title function_\">createSlice</span>({\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;adoptedPet&quot;</span>,\n  <span class=\"hljs-attr\">initialState</span>: {\n    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-literal\">null</span>,\n  },\n  <span class=\"hljs-attr\">reducers</span>: {\n    <span class=\"hljs-attr\">adopt</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">state, action</span>) =&gt;</span> {\n      state.<span class=\"hljs-property\">value</span> = action.<span class=\"hljs-property\">payload</span>;\n    },\n  },\n});\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> { adopt } = adoptedPetSlice.<span class=\"hljs-property\">actions</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> adoptedPetSlice.<span class=\"hljs-property\">reducer</span>;\n</code></pre>\n<ul>\n<li>Here you name your slice (what we&#39;re calling a bundle of reducers, state, and action creators)</li>\n<li>You give it an inital state</li>\n<li>You give it any reducers we need in our case, we just want a simple action that sets whatever the payload is to be what&#39;s stored. This common. Sometimes you may want to do some processing or math or something like that.</li>\n<li>RTK takes the liberty of making action creators and the actual reducers for you. This was something you used to have to code by hand.</li>\n<li>We export the reducer to use in the store.js file.</li>\n</ul>\n<p>Okay let&#39;s go <em>use this</em>. Go back to store.js</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> { configureStore } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@reduxjs/toolkit&quot;</span>;\n<span class=\"hljs-keyword\">import</span> adoptedPet <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./adoptedPetSlice&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> store = <span class=\"hljs-title function_\">configureStore</span>({\n  <span class=\"hljs-attr\">reducer</span>: {\n    adoptedPet,\n  },\n});\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> store;\n</code></pre>\n<p>Add the reducer from the slice we created.</p>\n<p>Okay, now in Details.jsx</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// add at top</span>\n<span class=\"hljs-comment\">// delete import AdoptedPetContext from &quot;./AdoptedPetContext&quot;;</span>\n<span class=\"hljs-keyword\">import</span> { useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>; <span class=\"hljs-comment\">// drop useContext</span>\n<span class=\"hljs-keyword\">import</span> { useDispatch } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-redux&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { adopt } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./adoptedPetSlice&quot;</span>;\n\n<span class=\"hljs-comment\">// delete the next two lines</span>\n<span class=\"hljs-comment\">// eslint-disable-next-line no-unused-vars</span>\n<span class=\"hljs-comment\">// const [_, setAdoptedPet] = useContext(AdoptedPetContext);</span>\n\n<span class=\"hljs-comment\">// add with the hooks at the top</span>\n<span class=\"hljs-keyword\">const</span> dispatch = <span class=\"hljs-title function_\">useDispatch</span>();\n\n<span class=\"hljs-comment\">// replace setAdoptedPet</span>\n<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>\n  <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> {\n    dispatch(adopt(pet));\n    navigate(&quot;/&quot;);\n  }}\n&gt;\n  […]\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>;\n</code></pre>\n<p>This is how to use Redux from a write persepctive (we&#39;ll look at read in a sec.) You use <code>dispatch</code> functions to dispatch an action (which <code>adopt</code> does for us). That payload will eventually be passed to the reducer we made which will update our store. Redux handles all of the informing React of when to re-render. If this feels a lot like context is because it works much the same way. They both inspired each others&#39; design.</p>\n<p>Okay, let&#39;s go do writing. Hop on over to SearchParams.js</p>\n<pre><code class=\"hljs language-jsx\"><span class=\"hljs-comment\">// delete</span>\n<span class=\"hljs-comment\">// import AdoptedPetContext from &quot;./AdoptedPetContext&quot;;</span>\n\n<span class=\"hljs-keyword\">import</span> { useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>; <span class=\"hljs-comment\">// drop useContext</span>\n<span class=\"hljs-keyword\">import</span> { useSelector } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-redux&quot;</span>;\n\n<span class=\"hljs-comment\">// delete const [adoptedPet] = useContext(AdoptedPetContext);</span>\n<span class=\"hljs-keyword\">const</span> adoptedPet = <span class=\"hljs-title function_\">useSelector</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">state</span>) =&gt;</span> state.<span class=\"hljs-property\">adoptedPet</span>.<span class=\"hljs-property\">value</span>);\n</code></pre>\n<p>That&#39;s it! You give <code>useSelector</code> a function that takes in the entire state tree and gives back just what you need. Keep in mind this is a subscription function: it will use this function to judge whether or not it needs to re-render your component. So don&#39;t just give it <code>state =&gt; state</code> or else it&#39;ll re-render on <em>every state change ever</em> which is likely not what you want.</p>\n<p>Again, this is all fairly similar to Context but it definitely has its upsides. Slices are easy to test. And it externalize React&#39;s app state management from React itself. This means you can treat state mutation separately from UI which is generally a good thing. RTK made this much more paletteable.</p>\n","slug":"redux-toolkit","title":"Redux Toolkit","section":"Redux","icon":"database","filePath":"/home/runner/work/complete-intro-to-react-v8/complete-intro-to-react-v8/lessons/14-redux/A-redux-toolkit.md","nextSlug":"/lessons/redux/more-app-state","prevSlug":"/lessons/typescript/refactor-app"}},"__N_SSG":true}