{"pageProps":{"post":{"attributes":{"section":"Server Side Rendering"},"html":"<blockquote>\n<p>Please start with a fresh copy of this app: <a href=\"https://github.com/btholt/citr-v8-project/tree/master/14-context\">Adopt Me!</a></p>\n</blockquote>\n<p>Performance is a central concern for front end developers. We should always be striving to serve the leanest web apps that perform faster than humans can think. This is as much a game of psychology as it is a a technological challenge. It&#39;s a challenge of loading the correct content first so a user can see a site and begin to make a decision of what they want to do (scroll down, click a button, log in, etc.) and then be prepared for that action before they make that decision.</p>\n<p>Enter server-side rendering. This is a technique where you run React on your Node.js server <em>before</em> you serve the request to the user and send down the first rendering of your website already done. This saves precious milliseconds+ on your site because otherwise the user has to download the HTML, then download the JavaScript, then execute the JS to get the app. In this case, they&#39;ll just download the HTML and see the first rendered page while React is loading in the background.</p>\n<p>While the total time to when the page is actually interactive is comparable, if a bit slower, the time to when the user <em>sees</em> something for the first time should be much faster, hence why this is a popular technique. So let&#39;s give it a shot.</p>\n<p>First, we need to remove all references to <code>window</code> or anything browser related from a path that <em>could</em> be called in Node. That means whenever we reference <code>window</code>, it&#39;ll have to be inside componentDidMount since componentDidMount doesn&#39;t get called in Node.</p>\n<p>We&#39;ll also have change where our app gets rendered. Make a new file called ClientApp.jsx. Put in there:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> { hydrateRoot } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-dom/client&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">BrowserRouter</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">App</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./App&quot;</span>;\n\n<span class=\"hljs-title function_\">hydrateRoot</span>(\n  <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;root&quot;</span>),\n  <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">BrowserRouter</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">BrowserRouter</span>&gt;</span></span>,\n  <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&quot;root&quot;</span>)\n);\n</code></pre>\n<p>This code will only get run in the browser, so any sort of browser related stuff can safely be done here (like analytics.) We&#39;re also using <code>React.hydrate</code> instead of <code>React.render</code> because this will hydrate existing markup with React magic ✨ rather than render it from scratch.</p>\n<p>Because ClientApp.jsx will now be the entry point to the app, not App.js, we&#39;ll need to fix that in the script tag in index.html. Change it from App.js to ClientApp.js</p>\n<p>Let&#39;s go fix App.jsx now:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// remove react-dom import</span>\n\n<span class=\"hljs-comment\">// remove Router from &lt;App /&gt;</span>\n\n<span class=\"hljs-comment\">// replace render at bottom</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;\n</code></pre>\n<p>Now let&#39;s make a ServerApp.jsx. We need this file to run through Vite so Node.js can render our app.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> { renderToPipeableStream } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-dom/server&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">StaticRouter</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom/server&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">App</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./App&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\">url, opts</span>) {\n  <span class=\"hljs-keyword\">const</span> stream = <span class=\"hljs-title function_\">renderToPipeableStream</span>(\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">StaticRouter</span> <span class=\"hljs-attr\">location</span>=<span class=\"hljs-string\">{url}</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">StaticRouter</span>&gt;</span></span>,\n    opts\n  );\n  <span class=\"hljs-keyword\">return</span> stream;\n}\n</code></pre>\n<p>This is code that will run in Node.js once we&#39;ve told Vite to transpile it. This will create a server-readable stream of React markup that we can send to the user.</p>\n<p>We need a few more modules. Run <code>npm install express@4.18.2</code> to get the framework we need for Node.</p>\n<p>Go change your index.html to use ClientApp.js instead of App.js</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;module&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;./ClientApp.jsx&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>Now in your package.json, add the following to your <code>&quot;scripts&quot;</code></p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-comment\">// inside scripts</span>\n<span class=\"hljs-attr\">&quot;build:client&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;vite build --outDir ../dist/client&quot;</span><span class=\"hljs-punctuation\">,</span>\n<span class=\"hljs-attr\">&quot;build:server&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;vite build --outDir ../dist/server --ssr ServerApp.jsx&quot;</span><span class=\"hljs-punctuation\">,</span>\n<span class=\"hljs-attr\">&quot;build&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;npm run build:client &amp;&amp; npm run build:server&quot;</span><span class=\"hljs-punctuation\">,</span>\n<span class=\"hljs-attr\">&quot;start&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;node server.js&quot;</span><span class=\"hljs-punctuation\">,</span>\n\n<span class=\"hljs-comment\">// outside scripts</span>\n<span class=\"hljs-attr\">&quot;type&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;module&quot;</span><span class=\"hljs-punctuation\">,</span>\n</code></pre>\n<p>This will allow us to build the app into static (pre-compiled, non-dev) assets and then start our server. This will also allow us to compile our app a second time so that Node.js can run it.</p>\n<p>We also have to identify to Node.js that we&#39;re using modules, not CommonJS which is where the type=module comes in.</p>\n<p>Let&#39;s finally go write our Node.js server:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> express <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;express&quot;</span>;\n<span class=\"hljs-keyword\">import</span> fs <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;fs&quot;</span>;\n<span class=\"hljs-keyword\">import</span> path <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;path&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { fileURLToPath } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;url&quot;</span>;\n<span class=\"hljs-keyword\">import</span> renderApp <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./dist/server/ServerApp.js&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> __dirname = path.<span class=\"hljs-title function_\">dirname</span>(<span class=\"hljs-title function_\">fileURLToPath</span>(<span class=\"hljs-keyword\">import</span>.<span class=\"hljs-property\">meta</span>.<span class=\"hljs-property\">url</span>));\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">PORT</span> = process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">PORT</span> || <span class=\"hljs-number\">3001</span>;\n\n<span class=\"hljs-keyword\">const</span> html = fs\n  .<span class=\"hljs-title function_\">readFileSync</span>(path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&quot;./dist/client/index.html&quot;</span>))\n  .<span class=\"hljs-title function_\">toString</span>();\n\n<span class=\"hljs-keyword\">const</span> parts = html.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&quot;not rendered&quot;</span>);\n\n<span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-title function_\">express</span>();\n\napp.<span class=\"hljs-title function_\">use</span>(\n  <span class=\"hljs-string\">&quot;/assets&quot;</span>,\n  express.<span class=\"hljs-title function_\">static</span>(path.<span class=\"hljs-title function_\">resolve</span>(__dirname, <span class=\"hljs-string\">&quot;./dist/client/assets&quot;</span>))\n);\napp.<span class=\"hljs-title function_\">use</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> {\n  res.<span class=\"hljs-title function_\">write</span>(parts[<span class=\"hljs-number\">0</span>]);\n  <span class=\"hljs-keyword\">const</span> stream = <span class=\"hljs-title function_\">renderApp</span>(req.<span class=\"hljs-property\">url</span>, {\n    <span class=\"hljs-title function_\">onShellReady</span>(<span class=\"hljs-params\"></span>) {\n      stream.<span class=\"hljs-title function_\">pipe</span>(res);\n    },\n    <span class=\"hljs-title function_\">onShellError</span>(<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-comment\">// do error handling</span>\n    },\n    <span class=\"hljs-title function_\">onAllReady</span>(<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-comment\">// last thing to write</span>\n      res.<span class=\"hljs-title function_\">write</span>(parts[<span class=\"hljs-number\">1</span>]);\n      res.<span class=\"hljs-title function_\">end</span>();\n    },\n    <span class=\"hljs-title function_\">onError</span>(<span class=\"hljs-params\">err</span>) {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(err);\n    },\n  });\n});\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`listening on http://localhost:<span class=\"hljs-subst\">${PORT}</span>`</span>);\napp.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-variable constant_\">PORT</span>);\n</code></pre>\n<ul>\n<li>[Express.js][ex] is a Node.js web server framework. It&#39;s the most common one and a simple one to learn.</li>\n<li>We&#39;ll be listening on port 3001 (<a href=\"\">http://locahost:<strong>3001</strong></a>) unless a environment variable is passed in saying otherwise. We do this because if you try to deploy this, you&#39;ll need to watch for PORT.</li>\n<li>We&#39;ll statically serve what Vite built.</li>\n<li>Anything that Vite <em>doesn&#39;t</em> serve, will be given our index.html. This lets the client-side app handle all the routing.</li>\n<li>We read the compiled HTML doc and split it around our <code>not rendered</code> statement. Then we can slot in our markup in between the divs, right where it should be.</li>\n<li>For crawlers (like Google), <em>don&#39;t</em> pipe onShellReady, and just hold the whole thing back until onAllReady. Then it looks like a whole complete request to a crawler.</li>\n</ul>\n<p>Run <code>npm run start</code> and then open <a href=\"\">http://localhost:3001</a> to see your server side rendered app. Notice it displays markup almost instantly.</p>\n<p>This is rendering the whole app to a Node.js stream. As parts are finished, it streams markup to the user. There are other options to do with just as a static stream but what&#39;s cool about this one is that it works just out of the box with Suspense and React.lazy so it&#39;ll server-side render those components and not force a user to wait for them.</p>\n<h2 id=\"react-query-and-experimental-fetch\">react-query and experimental fetch</h2>\n<p>This still only builds the front page of the app and it does not actually fetch the data for our React app. What if we could send the user a totally complete page. I can give you a little preview of how easy it&#39;s going to be soon to do that.</p>\n<p>If you&#39;re on Node.js 18, skip this step. If you&#39;re on Node.js 16, you need to add this to your npm run start command in your package.json</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-attr\">&quot;start&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;node --experimental-fetch server.js&quot;</span><span class=\"hljs-punctuation\">,</span>\n</code></pre>\n<p>Node.js just shipped fetch as a feature. In Node.js 16 you need a flag to use it.</p>\n<p>Now head to App.jsx and modify where you create the react-query query client.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> queryClient = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">QueryClient</span>({\n  <span class=\"hljs-attr\">defaultOptions</span>: {\n    <span class=\"hljs-attr\">queries</span>: {\n      <span class=\"hljs-attr\">staleTime</span>: <span class=\"hljs-title class_\">Infinity</span>,\n      <span class=\"hljs-attr\">cacheTime</span>: <span class=\"hljs-title class_\">Infinity</span>,\n      <span class=\"hljs-attr\">suspense</span>: <span class=\"hljs-literal\">true</span>,\n    },\n  },\n});\n</code></pre>\n<p>That <code>suspense</code> line will make react-query work with React&#39;s Suspense component which we were already using for React.lazy. This is experimental and very well could change in the future so don&#39;t ship this quite yet. But I wanted to show you how close we are!</p>\n<p>You can still accomplish this today but with a bit more code. A good way to do that would be:</p>\n<ol>\n<li>Fetch the API response first and cache it. Re-fetch it every so often (depending on how frequently that cache might get stale)</li>\n<li>Make <code>&lt;App /&gt;</code> accept a prop that it then passes into react-query&#39;s initialData option. <a href=\"https://tanstack.com/query/v4/docs/guides/ssr#using-initialdata\">See docs here for initialData</a></li>\n<li>In <code>ServerApp.jsx</code>, pass your cached data into <code>&lt;App /&gt;</code></li>\n<li>Render a separate <code>&lt;script&gt;</code> tag to your page with a JS object containing that object. Make sure it loads before React.js bootstraps</li>\n<li>In <code>ClientApp.jsx</code> pass that into <code>&lt;App /&gt;</code>.</li>\n</ol>\n<p>A lot of code, but it&#39;d work too! As an exercise, this would be great for you to explore how all these pieces fit together.</p>\n<h2 id=\"gitignore\">.gitignore</h2>\n<p>Make sure you add <code>dist/</code> to your .gitignore here. We don&#39;t want to commit built code.</p>\n<blockquote>\n<p>🏁 <a href=\"https://github.com/btholt/citr-v8-project/tree/master/server-side-rendering\">Click here to see the state of the project up until now: server-side-rendering</a></p>\n</blockquote>\n","slug":"server-side-rendering","title":"Server Side Rendering","section":"Advance React Performance","icon":"tachometer-alt","filePath":"/home/runner/work/complete-intro-to-react-v8/complete-intro-to-react-v8/lessons/11-advance-react-performance/B-server-side-rendering.md","nextSlug":"/lessons/low-priority-rerendering/deferred-values","prevSlug":"/lessons/advance-react-performance/code-splitting"}},"__N_SSG":true}