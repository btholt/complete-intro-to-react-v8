{"pageProps":{"post":{"attributes":{"description":"","title":"react-query"},"html":"<p>As we saw in the <a href=\"/core-react-concepts/effects\">Effects lesson</a> React has the ability to render, make a request to an async data source (like an API), and then re-render after the new data comes in. <code>useEffect</code> accomplishes this goal precisely.</p>\n<p>However, take it from me, when you start having a <em>lot</em> of effects in an app, it quickly can get unruly of what effect is happening when and performance can also begin to suffer when effects start happening in a rapid succession. It&#39;s possible to manage, just can be hard to wrap your mind around.</p>\n<p>Here I am going to teach you a library called <a href=\"https://tanstack.com/query/v4\">@tanstack/react-query</a>.</p>\n<pre><code class=\"language-bash\">npm install @tanstack/react-query@4.10.1\n</code></pre>\n<blockquote>\n<p><code>@tanstack/react-query</code> is the same people who do <code>react-query</code>. This is just the newer version. They now support more than just React.</p>\n</blockquote>\n<p>The idea behind React is that you want to cache most of what you fetch from a database. If you fetch the details of pet ID 1, you generally do not want to fetch it again if a user revisits that page: you&#39;d like to cache it. This is what react-query is going to do for you: it&#39;s a built in caching layer for these async data stores that works really well within the constraints of React. Let&#39;s see how to make our Details page use it.</p>\n<p>First thing, we need to wrap our app in a query client. In theory we could have multiple query clients for our app if we wanted multiple different caches to draw from (though I struggle to conceive of a reason to do that.) More concretely though is that it&#39;s using React context to pass our app&#39;s cache around. So let&#39;s go handle that.</p>\n<p>In App.jsx</p>\n<pre><code class=\"language-javascript\">// at top\nimport { QueryClient, QueryClientProvider } from &quot;@tanstack/react-query&quot;;\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: Infinity,\n      cacheTime: Infinity,\n    },\n  },\n});\n\n// inside &lt;BrowserRouter&gt; wrapping everything inside it\n&lt;QueryClientProvider client={queryClient}&gt;\n [‚Ä¶]\n&lt;/QueryClientProvider&gt;\n</code></pre>\n<p>This will wrap our app with the provider necessary to power react-query. We have to give it cache and stale times so that it will actually use its caching layer. Otherwise it&#39;ll fetch each time. Here we&#39;re saying &quot;never invalidate&quot; but in many apps you&#39;d probably want to still fetch every few minutes or so.</p>\n<p>Now make a file called fetchPet.js (or jsx):</p>\n<pre><code class=\"language-javascript\">const fetchPet = async ({ queryKey }) =&gt; {\n  const id = queryKey[1];\n  const apiRes = await fetch(`http://pets-v2.dev-apis.com/pets?id=${id}`);\n\n  if (!apiRes.ok) {\n    throw new Error(`details/${id} fetch not ok`);\n  }\n\n  return apiRes.json();\n};\n\nexport default fetchPet;\n</code></pre>\n<p>This is the function that will actually make the request to the API.</p>\n<ul>\n<li>Splitting it out allows it to be independently testable and reusable across our app</li>\n<li>Notice the <code>if</code> conditional. We need it to throw if there&#39;s an error and fetch wouldn&#39;t throw here if there&#39;s a 400 or a 500 error. We need it to.</li>\n<li>Notice we don&#39;t await the <code>json</code> response. Any async function is going to return a promise anyway so we don&#39;t need to await it in the function body. You could. It would do the same thing.</li>\n</ul>\n<p>Okay, let&#39;s change Details.jsx now</p>\n<pre><code class=\"language-javascript\">import { useParams } from &quot;react-router-dom&quot;;\nimport { useQuery } from &quot;@tanstack/react-query&quot;;\nimport fetchPet from &quot;./fetchPet&quot;;\n\nconst Details = () =&gt; {\n  const { id } = useParams();\n  const results = useQuery([&quot;details&quot;, id], fetchPet);\n\n  if (results.isLoading) {\n    return (\n      &lt;div className=&quot;loading-pane&quot;&gt;\n        &lt;h2 className=&quot;loader&quot;&gt;üåÄ&lt;/h2&gt;\n      &lt;/div&gt;\n    );\n  }\n\n  const pet = results.data.pets[0];\n\n  return (\n    &lt;div className=&quot;details&quot;&gt;\n      &lt;div&gt;\n        &lt;h1&gt;{pet.name}&lt;/h1&gt;\n        &lt;h2&gt;{`${pet.animal} ‚Äî ${pet.breed} ‚Äî ${pet.city}, ${pet.state}`}&lt;/h2&gt;\n        &lt;button&gt;Adopt {pet.name}&lt;/button&gt;\n        &lt;p&gt;{pet.description}&lt;/p&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default Details;\n</code></pre>\n<ul>\n<li>useQuery will actually use the queryClient that we instantiated above via context (we have a whole section later on context.)</li>\n<li>The first thing you give to useQuery is the query key. It could be a string e.g. we could have done <code>details:1</code> as the key for details 1 (similar to a Redis strategy for key naming.) However I like the array methodology. You can give it an array of keys. So the first key is <code>details</code> and then a subkey of that is <code>1</code> and it has to match both. You can also do it with objects and we will momentarily.</li>\n<li>The results object has a lot of booleans on it for isLoading, isError, isFetching, isPaused, etc. In this case react-query will make it <em>start</em> its first fetch (but not finish) and then continue rendering. Therefore we <em>must</em> handle the <code>isLoading</code> case (in addition to that just being a good idea)</li>\n</ul>\n<p>This should all work now! Notice if we navigate back and forth from a page, the first time it will load it and the second time it won&#39;t; it&#39;ll just pull it from the cache! Perfect! Exactly what we wanted.</p>\n<p>Let&#39;s go do useBreedList.js. First, let&#39;s split out the fetch command into fetchBreedList.js</p>\n<pre><code class=\"language-javascript\">async function fetchBreedList({ queryKey }) {\n  const animal = queryKey[1];\n\n  if (!animal) return [];\n\n  const res = await fetch(\n    `http://pets-v2.dev-apis.com/breeds?animal=${animal}`\n  );\n\n  if (!res.ok) {\n    throw new Error(`breeds ${animal} fetch not ok`);\n  }\n\n  return res.json();\n}\n\nexport default fetchBreedList;\n</code></pre>\n<p>And now refactor useBreedList.js</p>\n<pre><code class=\"language-javascript\">import { useQuery } from &quot;@tanstack/react-query&quot;;\nimport fetchBreedList from &quot;./fetchBreedList&quot;;\n\nexport default function useBreedList(animal) {\n  const results = useQuery([&quot;breeds&quot;, animal], fetchBreedList);\n\n  return [results?.data?.breeds ?? [], results.status];\n}\n</code></pre>\n<p>This got <em>a lot</em> simpler, didn&#39;t it? It&#39;s because react-query handles all the caching for us instead of us having to. Now go click around the animals drop down and see if it still works okay.</p>\n<h2 id=\"mutations\">Mutations</h2>\n<p>In this class we&#39;re just looking at fetching data from the server. These can be cached and we can avoid calling the server again if we have same parameters. However a mutation always needs to run: if we are trying to change something on the server, we can&#39;t avoid that call. That&#39;s where a mutation comes into play.</p>\n<p><a href=\"https://tanstack.com/query/v4/docs/framework/react/guides/mutations\">See the documentation here</a>.</p>\n<p>Nearly all the same concepts at play, just a little different to handle the fact you&#39;re POSTing data to a server.</p>\n<blockquote>\n<p>üèÅ <a href=\"https://github.com/btholt/citr-v8-project/tree/master/09-react-query\">Click here to see the state of the project up until now: 09-react-query</a></p>\n</blockquote>\n","slug":"react-query","title":"react-query","section":"React Capabilities","icon":"map","filePath":"/home/runner/work/complete-intro-to-react-v8/complete-intro-to-react-v8/lessons/05-react-capabilities/B-react-query.md","nextSlug":"/lessons/react-capabilities/uncontrolled-forms","prevSlug":"/lessons/react-capabilities/react-router"}},"__N_SSG":true}