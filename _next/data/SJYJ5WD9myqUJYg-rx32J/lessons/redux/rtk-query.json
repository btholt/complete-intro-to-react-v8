{"pageProps":{"post":{"attributes":{"description":"","title":"RTK Query"},"html":"<p>Very similar to @tanstack/react-query that we saw in Complete Intro, there is a Redux Toolkit Query (always abbreviated as RTK Query). It works extremely similarly to react-query but with a Redux twist on it. If you&#39;re using Redux, I recommend you use RTK Query instead of react-query. Likewise I wouldn&#39;t introduce RTK to your app <em>just</em> to use RTK Query. Just know both are similar and are wonderful to work with.</p>\n<p>So we&#39;re going to replace all of our uses of react-query with RTK Query.</p>\n<p>Make a file called petApiService.js. In there put:</p>\n<pre><code class=\"language-javascript\">import { createApi, fetchBaseQuery } from &quot;@reduxjs/toolkit/query/react&quot;;\n\nexport const petApi = createApi({\n  reducerPath: &quot;petApi&quot;,\n  baseQuery: fetchBaseQuery({ baseUrl: &quot;http://pets-v2.dev-apis.com&quot; }),\n  endpoints: (builder) =&gt; ({\n    getPet: builder.query({\n      query: (id) =&gt; ({ url: &quot;pets&quot;, params: { id } }),\n      transformResponse: (response) =&gt; response.pets[0],\n    }),\n  }),\n});\n\nexport const { useGetPetQuery } = petApi;\n</code></pre>\n<ul>\n<li>With RTK query you build these services around base URLs. In our case, our API is all on the same path so it all works out well. You then build endpoints which have their own sort of URL builders.</li>\n<li>We built a getPet endpoint. It takes in an ID and then uses that as a URL query parameter. So with that with an ID of 4 the URL built would be the <code>baseUrl</code> + the endpoint <code>url</code> + the params so <a href=\"http://pets-v2.dev-apis.com/pets?id=4\">http://pets-v2.dev-apis.com/pets?id=4</a></li>\n<li><code>transformResponse</code> is so you can extract the actual part of the response you want to keep. We just want the first pet in the pets array so we nab that.</li>\n<li>Finally <code>createApi</code> will create a hook for you to use in your app so we&#39;re going to export that.</li>\n</ul>\n<p>Okay, let&#39;s go put it in store.js now</p>\n<pre><code class=\"language-javascript\">import { petApi } from &quot;./petApiService&quot;; // import service\n\nconst store = configureStore({\n  reducer: {\n    adoptedPet,\n    searchParams,\n    [petApi.reducerPath]: petApi.reducer, // add reducer\n  },\n  middleware: (getDefaultMiddleware) =&gt;\n    getDefaultMiddleware().concat(petApi.middleware), // add middleware\n});\n\nexport default store;\n</code></pre>\n<ul>\n<li>We need to add our reducer to our store. RTK query will cache our responses directly in our Redux store for us with its generated reducers but we do need to add it to our store</li>\n<li>The middleware isn&#39;t strictly necessary but it does allow for additional feature like caching, invalidation, refetching, etc. I just always add it. But your app with basic caching does work without the middleware.</li>\n</ul>\n<p>Okay! Now we&#39;re ready to use this in React! Let&#39;s head to Details.jsx</p>\n<pre><code class=\"language-javascript\">// remove useQuery import\n// remove fetchPet import\nimport { useGetPetQuery } from &quot;./petApiService&quot;;\n\n// delete const results = useQuery([&quot;details&quot;, id], fetchPet);\n\nconst { isLoading, data: pet } = useGetPetQuery(id);\n\nif (isLoading) { // remove results.\n  […]\n}\n</code></pre>\n<p>And now it should work!! As you can see, very similar to react-query. Let&#39;s quickly do the other requests.</p>\n<p>Back in petApiService.js</p>\n<pre><code class=\"language-javascript\">// add two endpoints\nendpoints: (builder) =&gt; ({\n  […]\n  getBreeds: builder.query({\n    query: (animal) =&gt; ({ url: &quot;breeds&quot;, params: { animal } }),\n    transformResponse: (response) =&gt; response.breeds,\n  }),\n  search: builder.query({\n    query: ({ animal, location, breed }) =&gt; ({\n      url: &quot;pets&quot;,\n      params: { animal, location, breed },\n    }),\n    transformResponse: (response) =&gt; response.pets,\n  }),\n}),\n\nexport const { useGetBreedsQuery, useGetPetQuery, useSearchQuery } = petApi; // add exports\n</code></pre>\n<p>Now to useBreedList.js</p>\n<pre><code class=\"language-javascript\">import { useGetBreedsQuery } from &quot;./petApiService&quot;;\n\n// delete these two\n// import { useQuery } from &quot;@tanstack/react-query&quot;;\n// import fetchBreedList from &quot;./fetchBreedList&quot;;\n\nexport default function useBreedList(animal) {\n  // delete this line\n  // const results = useQuery([&quot;breeds&quot;, animal], fetchBreedList);\n\n  const { data: breeds, isLoading } = useGetBreedsQuery(animal, {\n    skip: !animal,\n  });\n\n  if (!animal) {\n    return [[], &quot;loaded&quot;];\n  }\n\n  return [breeds ?? [], isLoading ? &quot;loading&quot; : &quot;loaded&quot;];\n}\n</code></pre>\n<ul>\n<li>Very close to what we had.</li>\n<li>We&#39;re telling the hook &quot;hey, if there&#39;s no animal, don&#39;t fetch. Give the user back an empty array&quot;</li>\n<li>I&#39;m being lazy with the isLoaded status. You could look at <code>isLoaded</code>, <code>isFetching</code>, <code>isError</code>, <code>isSuccess</code>, etc. and come up with a better system. We&#39;re not using it so I&#39;m not working too hard on it.</li>\n</ul>\n<p>Last one. Head to SearchParam.jsx</p>\n<pre><code class=\"language-javascript\">// remove imports for fetchSearch and useQuery\nimport { useSearchQuery } from &quot;./petApiService&quot;;\n\n// replace useQuery call\nlet { data: pets } = useSearchQuery(searchParams);\npets = pets ?? [];\n</code></pre>\n<p>That&#39;s it! Congrats! You&#39;re now using RTK query. Again, this is awesome if you&#39;re already in Redux land but I end up mostly using react-query because I don&#39;t use Redux as much these days.</p>\n","slug":"rtk-query","title":"RTK Query","section":"Redux","icon":"database","filePath":"/home/runner/work/complete-intro-to-react-v8/complete-intro-to-react-v8/lessons/14-redux/C-rtk-query.md","nextSlug":"/lessons/redux/redux-dev-tools","prevSlug":"/lessons/redux/more-app-state"}},"__N_SSG":true}