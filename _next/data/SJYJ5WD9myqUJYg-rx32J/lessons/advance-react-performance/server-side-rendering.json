{"pageProps":{"post":{"attributes":{"section":"Server Side Rendering"},"html":"<blockquote>\n<p>Please start with a fresh copy of this app: <a href=\"https://github.com/btholt/citr-v8-project/tree/master/14-context\">Adopt Me!</a></p>\n</blockquote>\n<p>Performance is a central concern for front end developers. We should always be striving to serve the leanest web apps that perform faster than humans can think. This is as much a game of psychology as it is a a technological challenge. It&#39;s a challenge of loading the correct content first so a user can see a site and begin to make a decision of what they want to do (scroll down, click a button, log in, etc.) and then be prepared for that action before they make that decision.</p>\n<p>Enter server-side rendering. This is a technique where you run React on your Node.js server <em>before</em> you serve the request to the user and send down the first rendering of your website already done. This saves precious milliseconds+ on your site because otherwise the user has to download the HTML, then download the JavaScript, then execute the JS to get the app. In this case, they&#39;ll just download the HTML and see the first rendered page while React is loading in the background.</p>\n<p>While the total time to when the page is actually interactive is comparable, if a bit slower, the time to when the user <em>sees</em> something for the first time should be much faster, hence why this is a popular technique. So let&#39;s give it a shot.</p>\n<p>First, we need to remove all references to <code>window</code> or anything browser related from a path that <em>could</em> be called in Node. That means whenever we reference <code>window</code>, it&#39;ll have to be inside <code>hydrateRoot</code> since <code>hydrateRoot</code> doesn&#39;t get called in Node.</p>\n<p>We&#39;ll also have to change where our app gets rendered. Make a new file called ClientApp.jsx. Put in there:</p>\n<pre><code class=\"language-javascript\">import { hydrateRoot } from &quot;react-dom/client&quot;;\nimport { BrowserRouter } from &quot;react-router-dom&quot;;\nimport App from &quot;./App&quot;;\n\nhydrateRoot(\n  document.getElementById(&quot;root&quot;),\n  &lt;BrowserRouter&gt;\n    &lt;App /&gt;\n  &lt;/BrowserRouter&gt;\n);\n</code></pre>\n<p>This code will only get run in the browser, so any sort of browser related stuff can safely be done here (like analytics.) We&#39;re also using <code>React.hydrate</code> instead of <code>React.render</code> because this will hydrate existing markup with React magic ✨ rather than render it from scratch.</p>\n<p>Because ClientApp.jsx will now be the entry point to the app, not App.js, we&#39;ll need to fix that in the script tag in index.html. Change it from App.js to ClientApp.js</p>\n<pre><code class=\"language-html\">&lt;script type=&quot;module&quot; src=&quot;./ClientApp.jsx&quot;&gt;&lt;/script&gt;\n</code></pre>\n<p>Let&#39;s go fix App.jsx now:</p>\n<pre><code class=\"language-javascript\">// remove react-dom import\n\n// remove BrowserRouter from &lt;App /&gt; and remove import\n\n// replace render at bottom\nexport default App;\n</code></pre>\n<p>Now let&#39;s make a ServerApp.jsx. We need this file to run through Vite so Node.js can render our app.</p>\n<pre><code class=\"language-javascript\">import { renderToPipeableStream } from &quot;react-dom/server&quot;;\nimport { StaticRouter } from &quot;react-router-dom/server&quot;;\nimport App from &quot;./App&quot;;\n\nexport default function render(url, opts) {\n  const stream = renderToPipeableStream(\n    &lt;StaticRouter location={url}&gt;\n      &lt;App /&gt;\n    &lt;/StaticRouter&gt;,\n    opts\n  );\n  return stream;\n}\n</code></pre>\n<p>This is code that will run in Node.js once we&#39;ve told Vite to transpile it. This will create a server-readable stream of React markup that we can send to the user.</p>\n<p>We need a few more modules. Run <code>npm install express@4.18.2</code> to get the framework we need for Node.</p>\n<p>Now in your package.json, add the following to your <code>&quot;scripts&quot;</code></p>\n<pre><code class=\"language-json\">// inside scripts\n&quot;build:client&quot;: &quot;vite build --outDir ../dist/client&quot;,\n&quot;build:server&quot;: &quot;vite build --outDir ../dist/server --ssr ServerApp.jsx&quot;,\n&quot;build&quot;: &quot;npm run build:client &amp;&amp; npm run build:server&quot;,\n&quot;start&quot;: &quot;node server.js&quot;,\n\n// outside scripts\n&quot;type&quot;: &quot;module&quot;,\n</code></pre>\n<p>This will allow us to build the app into static (pre-compiled, non-dev) assets and then start our server. This will also allow us to compile our app a second time so that Node.js can run it.</p>\n<p>We also have to identify to Node.js that we&#39;re using modules, not CommonJS which is where the type=module comes in.</p>\n<p>Let&#39;s create <code>&quot;server.js&quot;</code> in our project root and finally go write our Node.js server:</p>\n<pre><code class=\"language-javascript\">import express from &quot;express&quot;;\nimport fs from &quot;fs&quot;;\nimport path from &quot;path&quot;;\nimport { fileURLToPath } from &quot;url&quot;;\nimport renderApp from &quot;./dist/server/ServerApp.js&quot;;\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\n\nconst PORT = process.env.PORT || 3001;\n\nconst html = fs\n  .readFileSync(path.resolve(__dirname, &quot;./dist/client/index.html&quot;))\n  .toString();\n\nconst parts = html.split(&quot;not rendered&quot;);\n\nconst app = express();\n\napp.use(\n  &quot;/assets&quot;,\n  express.static(path.resolve(__dirname, &quot;./dist/client/assets&quot;))\n);\napp.use((req, res) =&gt; {\n  res.write(parts[0]);\n  const stream = renderApp(req.url, {\n    onShellReady() {\n      stream.pipe(res);\n    },\n    onShellError() {\n      // do error handling\n    },\n    onAllReady() {\n      // last thing to write\n      res.write(parts[1]);\n      res.end();\n    },\n    onError(err) {\n      console.error(err);\n    },\n  });\n});\n\nconsole.log(`listening on http://localhost:${PORT}`);\napp.listen(PORT);\n</code></pre>\n<ul>\n<li><a href=\"https://expressjs.com\">Express.js</a> is a Node.js web server framework. It&#39;s the most common one and a simple one to learn.</li>\n<li>We&#39;ll be listening on port 3001 (<a href=\"\">http://locahost:<strong>3001</strong></a>) unless an environment variable is passed in saying otherwise. We do this because if you try to deploy this, you&#39;ll need to watch for PORT.</li>\n<li>We&#39;ll statically serve what Vite built.</li>\n<li>Anything that Vite <em>doesn&#39;t</em> serve, will be given our index.html. This lets the client-side app handle all the routing.</li>\n<li>We read the compiled HTML doc and split it around our <code>not rendered</code> statement. Then we can slot in our markup in between the divs, right where it should be.</li>\n<li>For crawlers (like Google), <em>don&#39;t</em> pipe onShellReady, and just hold the whole thing back until onAllReady. Then it looks like a whole complete request to a crawler.</li>\n</ul>\n<p>Run <code>npm run start</code> and then open <a href=\"\">http://localhost:3001</a> to see your server side rendered app. Notice it displays markup almost instantly.</p>\n<p>This is rendering the whole app to a Node.js stream. As parts are finished, it streams markup to the user. There are other options to do with just as a static stream but what&#39;s cool about this one is that it works just out of the box with Suspense and React.lazy so it&#39;ll server-side render those components and not force a user to wait for them.</p>\n<h2 id=\"react-query-and-experimental-fetch\">react-query and experimental fetch</h2>\n<p>This still only builds the front page of the app and it does not actually fetch the data for our React app. What if we could send the user a totally complete page. I can give you a little preview of how easy it&#39;s going to be soon to do that.</p>\n<p>If you&#39;re on Node.js 18, skip this step. If you&#39;re on Node.js 16, you need to add this to your npm run start command in your package.json</p>\n<pre><code class=\"language-json\">&quot;start&quot;: &quot;node --experimental-fetch server.js&quot;,\n</code></pre>\n<p>Node.js just shipped fetch as a feature. In Node.js 16 you need a flag to use it.</p>\n<p>Now head to App.jsx and modify where you create the react-query query client.</p>\n<pre><code class=\"language-javascript\">const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: Infinity,\n      cacheTime: Infinity,\n      suspense: true,\n    },\n  },\n});\n</code></pre>\n<p>That <code>suspense</code> line will make react-query work with React&#39;s Suspense component which we were already using for React.lazy. This is experimental and very well could change in the future so don&#39;t ship this quite yet. But I wanted to show you how close we are!</p>\n<p>You can still accomplish this today but with a bit more code. A good way to do that would be:</p>\n<ol>\n<li>Fetch the API response first and cache it. Re-fetch it every so often (depending on how frequently that cache might get stale)</li>\n<li>Make <code>&lt;App /&gt;</code> accept a prop that it then passes into react-query&#39;s initialData option. <a href=\"https://tanstack.com/query/v4/docs/guides/ssr#using-initialdata\">See docs here for initialData</a></li>\n<li>In <code>ServerApp.jsx</code>, pass your cached data into <code>&lt;App /&gt;</code></li>\n<li>Render a separate <code>&lt;script&gt;</code> tag to your page with a JS object containing that object. Make sure it loads before React.js bootstraps</li>\n<li>In <code>ClientApp.jsx</code> pass that into <code>&lt;App /&gt;</code>.</li>\n</ol>\n<p>A lot of code, but it&#39;d work too! As an exercise, this would be great for you to explore how all these pieces fit together.</p>\n<h2 id=\"gitignore\">.gitignore</h2>\n<p>Make sure you add <code>dist/</code> to your .gitignore here. We don&#39;t want to commit built code.</p>\n<blockquote>\n<p>🏁 <a href=\"https://github.com/btholt/citr-v8-project/tree/master/server-side-rendering\">Click here to see the state of the project up until now: server-side-rendering</a></p>\n</blockquote>\n","slug":"server-side-rendering","title":"Server Side Rendering","section":"Advance React Performance","icon":"tachometer-alt","filePath":"/home/runner/work/complete-intro-to-react-v8/complete-intro-to-react-v8/lessons/11-advance-react-performance/B-server-side-rendering.md","nextSlug":"/lessons/low-priority-rerendering/deferred-values","prevSlug":"/lessons/advance-react-performance/code-splitting"}},"__N_SSG":true}