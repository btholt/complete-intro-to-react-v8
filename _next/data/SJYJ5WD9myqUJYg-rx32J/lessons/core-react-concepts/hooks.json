{"pageProps":{"post":{"attributes":{"description":"React manages view state through a mechanism called hooks. Brian teaches you how to use them as you build components."},"html":"<p>Now we want to make it so you can modify what your search parameters are. Let&#39;s make a new route called SearchParams.jsx and have it accept these search parameters.</p>\n<pre><code class=\"language-javascript\">const SearchParams = () =&gt; {\n  const location = &quot;Seattle, WA&quot;;\n  return (\n    &lt;div className=&quot;search-params&quot;&gt;\n      &lt;form&gt;\n        &lt;label htmlFor=&quot;location&quot;&gt;\n          Location\n          &lt;input id=&quot;location&quot; value={location} placeholder=&quot;Location&quot; /&gt;\n        &lt;/label&gt;\n        &lt;button&gt;Submit&lt;/button&gt;\n      &lt;/form&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default SearchParams;\n</code></pre>\n<p>Now add it to your routes:</p>\n<pre><code class=\"language-javascript\">// delete Pet import, and add SearchParams\nimport SearchParams from &quot;./SearchParams&quot;;\n\n// in App.jsx, replace all the Pets\n&lt;SearchParams /&gt;;\n</code></pre>\n<blockquote>\n<p>üö® You&#39;ll have some errors in the console, that&#39;s okay.</p>\n</blockquote>\n<p>Now navigate to <a href=\"\">http://localhost:5173/</a> and see that you have one input box that says &quot;Seattle, WA&quot;. Try and type in it. You&#39;ll see that you can&#39;t modify it. Why? Let&#39;s think about how React works: when you type in the input, React detects that a DOM event happens. When that happens, React thinks <em>something</em> may have changed so it runs a re-render. Providing your render functions are fast, this is a very quick operation. It then diffs what&#39;s currently there and what its render pass came up with. It then updates the minimum amount of DOM necessary.</p>\n<p>Notice we&#39;re using <code>className</code> instead of <code>class</code> on the HTML element for CSS classes. This is because <code>class</code> is a reserved word in JS and JSX is still just JS. So instead they opted to use <code>className</code> which is the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/className\">name of the JS API</a> for interacting with class names.</p>\n<p>Like <code>className</code>, <code>htmlFor</code> is used because <code>for</code> is a reserved word in JS.</p>\n<p>So if we type in our input and it re-renders, what gets out in the <code>input</code> tag? Well, its value is tied to <code>location</code> and nothing changed that, so it remains the same. In other words, two way data binding is <em>not</em> free in React. I say this is a feature because it makes you explicit on how you handle your data. Let&#39;s go make it work.</p>\n<pre><code class=\"language-javascript\">// in SearchParams.jsx\nimport { useState } from &quot;react&quot;;\n\n// replace location\nconst [location, setLocation] = useState(&quot;&quot;);\n\n// replace input\n&lt;input\n  id=&quot;location&quot;\n  value={location}\n  placeholder=&quot;Location&quot;\n  onChange={(e) =&gt; setLocation(e.target.value)}\n/&gt;\n</code></pre>\n<ul>\n<li>This is called a hook. Other frameworks like Vue have started adopting it as well.</li>\n<li>A hook called such (in my head) because it&#39;s a hook that gets caught every time the render function gets called. Because the hooks get called in the same order every single time, they&#39;ll always point to the same piece of state. Because of that they can be stateful: you can keep pieces of mutable state using hooks and then modify them later using their provided updater functions.</li>\n<li>An <em>absolutely key</em> concept for you to grasp is hooks rely on this strict ordering. As such, <strong>do not put hooks inside if statements or loops</strong>. If you do, you&#39;ll have insane bugs that involve <code>useState</code> returning <em>the wrong state</em>. If you see <code>useState</code> returning the wrong piece of state, this is likely what you did.</li>\n<li>Because the previous point is so absolutely critical, the React team has provided us with a lint rule that help us not fall into that trap. That lint rule relies on us, the developers, to follow the convention of calling our hooks <code>useXxxxxx</code>. If you&#39;re willing to do that, the lint rules will guard you from calling the hooks out of order.</li>\n<li>The argument given to <code>useState</code> is the default value. In our case, we could give it <code>&quot;Seattle, WA&quot;</code> as our default value but let&#39;s give it a default empty string value.</li>\n<li><code>useState</code> returns to us an array with two things in it: the current value of that state and a function to update that state. We&#39;re using a feature of JavaScript called destructuring to get both of those things out of the array.</li>\n<li>We use the <code>setLocation</code> function in the <code>onChange</code> attribute of the input. Every time the input is typed into, it&#39;s going to call that function which calls <code>setLocation</code> with what has been typed into the input. When <code>setLocation</code> is called, React knows that its state has been modified and kicks off a re-render.</li>\n<li>You can make your own custom hooks; <code>useState</code> is just one of many.</li>\n<li>Historically, React has been written using <code>class</code>es with state being on the instance of the component. This is still a supported pattern in React. We&#39;ll see how to do it later.</li>\n</ul>\n<blockquote>\n<p>I&#39;m showing you how to do a &quot;controlled form&quot; in that we&#39;re using hooks to control each part of the form. In reality, it&#39;d be better to leave these <em>uncontrolled</em> (aka don&#39;t set the value) and wrap the whole thing in a form. Then we can listen for submit events and use that event to gather info off the form. This is less code and less burdensome to write. If you have a standard form sort of thing to write, do that as an uncontrolled form. If you need to do dynamic validation, react to a user typing a la typeahead (functionality that provides real-time suggestions), or something of the ilk, then a controlled input is perfect, otherwise stick to uncontrolled.</p>\n</blockquote>\n<p>Let&#39;s add the ESLint rule. Run <code>npm install -D eslint-plugin-react-hooks@4.6.0</code>. Add this to ESLint:</p>\n<pre><code class=\"language-json\">{\n  &quot;extends&quot;: [\n    ‚Ä¶\n    &quot;plugin:react-hooks/recommended&quot;,\n    ‚Ä¶\n  ]\n}\n</code></pre>\n<blockquote>\n<p>The order of extends isn&#39;t particularly important to us <em>except</em> the Prettier one <em>must</em> be last. That one serves to turn off rules the others ones enable.</p>\n</blockquote>\n<p>Let&#39;s next make the animal drop down.</p>\n<pre><code class=\"language-javascript\">// under the imports\nconst ANIMALS = [&quot;bird&quot;, &quot;cat&quot;, &quot;dog&quot;, &quot;rabbit&quot;, &quot;reptile&quot;];\n\n// under location\nconst [animal, setAnimal] = useState(&quot;&quot;);\n\n// under the location label\n&lt;label htmlFor=&quot;animal&quot;&gt;\n  Animal\n  &lt;select\n    id=&quot;animal&quot;\n    value={animal}\n    onChange={(e) =&gt; {\n      setAnimal(e.target.value);\n      setBreed(&quot;&quot;);\n    }}\n    onBlur={(e) =&gt; {\n      setAnimal(e.target.value);\n      setBreed(&quot;&quot;);\n    }}\n  &gt;\n    &lt;option /&gt;\n    {ANIMALS.map((animal) =&gt; (\n      &lt;option key={animal} value={animal}&gt;\n        {animal}\n      &lt;/option&gt;\n    ))}\n  &lt;/select&gt;\n&lt;/label&gt;\n</code></pre>\n<ul>\n<li>You can use <code>useState</code> as many times as you need for various pieces of state! Again, this is why ordering is important because React relies on <code>useState</code> to be called in strictly the same order every time so it can give you the same piece of state.</li>\n<li>Similar to above. We&#39;re using <code>onChange</code> and <code>onBlur</code> because it makes it more accessible.</li>\n<li>Whenever you set the animal to be a new animal, you have to clear out the breed. If you select a dog, then select a poodle, then select cat, it wouldn&#39;t make sense for you to search for a poodle cat. Hence you need to clear out breed when you select a new animal.</li>\n</ul>\n<p>Let&#39;s make a second dropdown so you can select a breed as well as an animal.</p>\n<pre><code class=\"language-javascript\">// under your other state inside the component\n  const [breed, setBreed] = useState(&quot;&quot;);\n  const breeds = [];\n\n// under the animal label\n &lt;label htmlFor=&quot;breed&quot;&gt;\n          Breed\n          &lt;select\n            disabled={!breeds.length}\n            id=&quot;breed&quot;\n            value={breed}\n            onChange={(e) =&gt; setBreed(e.target.value)}\n            onBlur={(e) =&gt; setBreed(e.target.value)}\n          &gt;\n            &lt;option /&gt;\n            {breeds.map((breed) =&gt; (\n              &lt;option key={breed} value={breed}&gt;\n                {breed}\n              &lt;/option&gt;\n            ))}\n          &lt;/select&gt;\n        &lt;/label&gt;\n</code></pre>\n<p>So now we have a breed dropdown. The only really new thing we did was use the <code>disabled</code> property to disable the dropdown when you don&#39;t have any breeds. We&#39;re going to use the API to request breeds based on the animal selected. If you select <code>dog</code>, you want to see poodles, labradors, and chihuahuas not parrots, tabbies, and Maine coons. The API has an endpoint, if you give it a valid animal. We&#39;ll show you how to do that in the next lesson with effects.</p>\n<blockquote>\n<p>üèÅ <a href=\"https://github.com/btholt/citr-v8-project/tree/master/04-hooks\">Click here to see the state of the project up until now: 04-hooks</a></p>\n</blockquote>\n","slug":"hooks","title":"Hooks","section":"Core React Concepts","icon":"book","filePath":"/home/runner/work/complete-intro-to-react-v8/complete-intro-to-react-v8/lessons/04-core-react-concepts/B-hooks.md","nextSlug":"/lessons/core-react-concepts/effects","prevSlug":"/lessons/core-react-concepts/jsx"}},"__N_SSG":true}