{"pageProps":{"post":{"attributes":{"description":"Portals allow you to render to a place outside of a component from within a component. Think of a contextual nav bar or side nav."},"html":"<p>Another nice feature React is something called a Portal. You can think of the portal as a separate mount point (the actual DOM node which your app is put into) for your React app. A common use case for this is going to be doing modals. You&#39;ll have your normal app with its normal mount point and then you can also put different content into a separate mount point (like a modal or a contextual nav bar) directly from a component. Pretty cool!</p>\n<p>First thing, let&#39;s go into index.html and add a separate mount point:</p>\n<pre><code class=\"language-html\">&lt;!-- above #root --&gt;\n&lt;div id=&quot;modal&quot;&gt;&lt;/div&gt;\n</code></pre>\n<p>This where the modal will actually be mounted whenever we render to this portal. Totally separate from our app root.</p>\n<p>Next create a file called Modal.jsx:</p>\n<pre><code class=\"language-javascript\">import React, { useEffect, useRef } from &quot;react&quot;;\nimport { createPortal } from &quot;react-dom&quot;;\n\nconst Modal = ({ children }) =&gt; {\n  const elRef = useRef(null);\n  if (!elRef.current) {\n    elRef.current = document.createElement(&quot;div&quot;);\n  }\n\n  useEffect(() =&gt; {\n    const modalRoot = document.getElementById(&quot;modal&quot;);\n    modalRoot.appendChild(elRef.current);\n    return () =&gt; modalRoot.removeChild(elRef.current);\n  }, []);\n\n  return createPortal(&lt;div&gt;{children}&lt;/div&gt;, elRef.current);\n};\n\nexport default Modal;\n</code></pre>\n<ul>\n<li>This will mount a div and mount inside of the portal whenever the Modal is rendered and then <em>remove</em> itself whenever it&#39;s unrendered.</li>\n<li>We&#39;re using the feature of <code>useEffect</code> that if you need to clean up after you&#39;re done (we need to remove the div once the Modal is no longer being rendered) you can return a function inside of <code>useEffect</code> that cleans up.</li>\n<li>We&#39;re also using a ref here via the hook <code>useRef</code>. Refs are like instance variables for function components. Whereas on a class you&#39;d say <code>this.myVar</code> to refer to an instance variable, with function components you can use refs. They&#39;re containers of state that live outside a function&#39;s closure state which means anytime I refer to <code>elRef.current</code>, it&#39;s <strong>always referring to the same element</strong>. This is different from a <code>useState</code> call because the variable returned from that <code>useState</code> call will <strong>always refer to the state of the variable when that function was called.</strong> It seems like a weird hair to split but it&#39;s important when you have async calls and effects because that variable can change and nearly always you want the <code>useState</code> variable, but with something like a portal it&#39;s important we always refer to the same DOM div; we don&#39;t want a lot of portals.</li>\n<li>Down at the bottom we use React&#39;s <code>createPortal</code> to pass the children (whatever you put inside <code>&lt;Modal&gt;&lt;/Modal&gt;</code>) to the portal div.</li>\n</ul>\n<p>Now go to Details.jsx and add:</p>\n<pre><code class=\"language-javascript\">// at the top\nimport { useState } from &quot;react&quot;;\nimport Modal from &quot;./Modal&quot;;\n\n// add showModal\nconst [showModal, setShowModal] = useState(false);\n\n// add onClick to &lt;button&gt;\n&lt;button onClick={() =&gt; setShowModal(true)}&gt;Adopt {pet.name}&lt;/button&gt;;\n\n// below description\n{\n  showModal ? (\n    &lt;Modal&gt;\n      &lt;div&gt;\n        &lt;h1&gt;Would you like to adopt {pet.name}?&lt;/h1&gt;\n        &lt;div className=&quot;buttons&quot;&gt;\n          &lt;button&gt;Yes&lt;/button&gt;\n          &lt;button onClick={() =&gt; setShowModal(false)}&gt;No&lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/Modal&gt;\n  ) : null; // you have to remove this semi-colon, my auto-formatter adds it back if I delete it\n}\n</code></pre>\n<p>Notice that despite we&#39;re rendering a whole different part of the DOM we&#39;re still referencing the state in Details.jsx. This is the magic of Portals. You can use state but render in different parts of the DOM. Imagine a sidebar with contextual navigation. Or a contextual footer. It opens up a lot of cool possibilities. React Router has some cool features built into that take advantage of this as well.</p>\n<p>We&#39;ll add a &quot;yes&quot; function here in the next lesson</p>\n<p>That&#39;s it! That&#39;s how you make a modal using a portal in React. This used to be significantly more difficult to do but with portals it became trivial. The nice thing about portals is that despite the actual elements being in different DOM trees, these are in the same React trees, so you can do event bubbling up from the modal. Some times this is useful if you want to make your Modal more flexible (like we did.)</p>\n<blockquote>\n<p>üèÅ <a href=\"https://github.com/btholt/citr-v8-project/tree/master/13-portals-and-refs\">Click here to see the state of the project up until now: 13-portals-and-refs</a></p>\n</blockquote>\n","slug":"portals-and-refs","title":"Portals and Refs","section":"Special Case React Tools","icon":"bolt","filePath":"/home/runner/work/complete-intro-to-react-v8/complete-intro-to-react-v8/lessons/06-special-case-react-tools/B-portals-and-refs.md","nextSlug":"/lessons/special-case-react-tools/context","prevSlug":"/lessons/special-case-react-tools/error-boundaries"}},"__N_SSG":true}